{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./source/vue/observe/dep.js","webpack:///./source/vue/observe/watcher.js","webpack:///./source/vue/utils.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/timers-browserify/main.js","webpack:///./node_modules/setimmediate/setImmediate.js","webpack:///./node_modules/process/browser.js","webpack:///./source/vue/observe/array.js","webpack:///./source/vue/observe/observer.js","webpack:///./source/vue/observe/index.js","webpack:///./source/vue/vdom/create-element.js","webpack:///./source/vue/vdom/h.js","webpack:///./source/vue/vdom/patch.js","webpack:///./source/vue/index.js","webpack:///./src/history/index2.js","webpack:///./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","id","Dep","this","subs","watcher","push","forEach","update","target","addDep","stack","pushTarget","popTarget","pop","length","has","queue","flushQueue","run","callbacks","vm","exprOrfn","cb","opts","getValue","user","lazy","dirty","deps","depsId","Set","immediate","undefined","dep","add","addSub","depend","timerFunc","Promise","resolve","then","MutationObserver","observe","textNode","document","createTextNode","characterData","textContent","setImmediate","setTimeout","nextTick","queueWatcher","utils","expor","split","reduce","memo","current","node","expr","replace","args","JSON","stringify","g","Function","e","window","self","apply","Timeout","clearFn","_id","_clearFn","scope","arguments","clearTimeout","setInterval","clearInterval","timeout","close","unref","ref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","global","clearImmediate","registerImmediate","html","channel","messagePrefix","onGlobalMessage","nextHandle","tasksByHandle","currentlyRunningATask","doc","attachTo","getPrototypeOf","toString","process","handle","runIfPresent","postMessage","importScripts","postMessageIsAsynchronous","oldOnMessage","onmessage","canUsePostMessage","MessageChannel","port1","event","data","port2","createElement","documentElement","script","onreadystatechange","removeChild","appendChild","Math","random","source","indexOf","slice","addEventListener","attachEvent","callback","Array","task","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","currentQueue","draining","queueIndex","cleanUpNextTick","concat","drainQueue","len","marker","runClearTimeout","Item","array","noop","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","oldArrayProtoMethods","arrayMethods","observerArray","inserted","method","__ob__","notify","definReative","childOb","dependArray","currentItem","isArray","newVal","__proto__","walk","keys","initState","$options","_data","proxy","initData","computed","watchers","_watchersComputed","userDef","createComputedGetter","initComputed","watch","handler","createWatcher","initDataWatch","newKey","evaluate","$watch","tag","props","children","text","h","map","child","vnode","container","el","createElm","upadteProperties","oldProps","console","log","newProps","newStyle","style","oldStyle","styleName","className","class","patch","oldVnode","newVnode","parentNode","replaceChild","oldChildren","newChildren","parent","oldStartIndex","oldStartVnode","oldEndIndex","oldEndVnode","newStartIndex","newStartVnode","newEndIndex","newEndVnode","index","makeIndexByKey","isSameNode","insertBefore","nextSibling","moveIndex","moveVnode","ele","updateChildren","innerHTML","oldNode","newNode","Vue","options","_init","$mount","_update","$el","preVnode","_render","render","querySelector","query","backgroundColor","fontSize","background","getElementById","msg"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","let id = 0;\nclass Dep {\n    constructor() {\n        this.id = id++;\n        this.subs = [];\n    }\n    addSub(watcher) { // 订阅  就是将调用ADDsub时传入的内容保存到数组中\n        this.subs.push(watcher);\n    }\n    notify() { //发布\n        this.subs.forEach(watcher => watcher.update());\n    }\n    depend() {\n        if (Dep.target) { //为了防止直接调用depengd\n            //Dep.target是一个渲染watcher dep可以计算watch  watch也可以计算dep\n            Dep.target.addDep(this); //希望可以在watcher中互相记忆  让watcher 可以记住Dep\n\n        }\n    }\n}\n//用来保存当前的watcher\nlet stack = [];\nexport function pushTarget(watcher) {\n    Dep.target = watcher;\n    stack.push(watcher);\n}\nexport function popTarget() {\n   stack.pop();\n   Dep.target = stack[stack.length - 1];//取栈的最后一个\n}\nexport default Dep; //用来收集依赖收集的是watcher\n//观察者模式 \n// let dep = new Dep();\n// dep.addSub({\n//     update() {\n//         console.log(1)\n//     }\n// })\n// dep.addSub({\n//     update() {\n//         console.log(2)\n//     }\n// })\n// dep.notify();\n","\nlet id = 0;\nimport { pushTarget, popTarget } from './dep'\nimport { utils } from '../utils'\nclass Watcher {\n    /**\n     * \n     * @param {*} vm 当前组件的实例\n     * @param {*} exprOrfn 用户传入的是一个表达式可能是一个函数\n     * @param {*} cb 用户传入的回调函数  vm.$watch('msg;, cb)\n     * @param {*} opts //一些其他参数\n     */\n    //\n    constructor(vm, exprOrfn, cb = () => { }, opts = {}) {\n        //vm当前组件实例\n        this.vm = vm;\n        this.exprOrfn = exprOrfn;\n        if (typeof exprOrfn === 'function') {\n            this.getter = exprOrfn;//getter就是new Wacher的第二个参数\n        } else {\n            this.getter = function () { //如果调用此方法 会将vm上对应的表达式取出来\n                // console.log(exprOrfn, 'exprOrfn---');\n                // exprOrfn ----  msg  utils.getValue(vm, exprOrfn) --- value\n                // console.log(utils.getValue(vm, exprOrfn));\n                return utils.getValue(vm, exprOrfn);\n            }\n        }\n        if (opts.user) {//标识用户自己写的watch\n            this.user = true;\n        }\n        this.lazy = opts.lazy;//计算属性\n        this.dirty = this.lazy;\n        this.cb = cb;\n        this.opts = opts;\n        this.deps = [];\n        this.depsId = new Set();\n        this.id = id++;\n        //创建watch实\n        this.immediate = opts.immediate;\n        //如果当前是计算属性  不会默认调用get\n        this.value = this.lazy ? undefined: this.get(); // 创建一个watcher 执行自身的getter方法\n        if (this.immediate) {\n            this.cb(this.value);\n        }\n\n    }\n    get() {\n        //默认创建watch就会调用\n        pushTarget(this); // 渲染watcher  Dep.target = watcher msg变化了  需要让这个watch重新执行\n        // fullname(){}\n        let value = this.getter.call(this.vm); //当前传入的函数执行  会更新属兔 会调用当前属性的get方法 给当前的属性加一个dep dep.addSub()  \n        //如果客户修改值了  会调用set方法  dep.notify  => 调用watch的update方法\n        popTarget();\n        return value;\n    }\n    evaluate() {\n        this.value = this.get(); //this  计算属性watcher\n        this.dirty = false;\n    }\n    addDep(dep) {//统一个watch 不应该重复记录dep\n        let id = dep.id;//masg 的dep\n        if (!this.depsId.has(id)) {\n            this.depsId.add(id);\n            this.deps.push(dep);\n            dep.addSub(this);\n        }\n\n\n    }\n    depend() { //deps firsename lastNmae \n        let i = this.deps.length;\n        while(i--) {\n            this.deps[i].depend();\n        }\n    }\n    //如果客户修改值了  会调用set方法  dep.notify  => 调用watch的update方法\n    update() {\n        // this.get();\n        // debugger;\n        if (this.lazy) {\n            this.dirty = true;\n        }else {\n            queueWatcher(this);\n        }\n      \n    }\n    run() {\n        let value = this.get(); //新值\n        if (this.value !== value) {\n            this.cb(value, this.value);\n        }\n    }\n\n}\nlet has = {}; //对重复的watcher 进行过滤操作\nlet queue = [];\nfunction flushQueue() { //等待当前这一轮全部更新  再去执行watcher\n    queue.forEach(watcher => watcher.run());\n    has = {}; //恢复正常\n    queue = [];\n}\nfunction queueWatcher(watcher) {\n    let id = watcher.id;\n    if (has[id] == null) {\n        has[id] = true;\n        queue.push(watcher); //相同的wacher 只会存一个\n        //延迟清空队列\n        // nextTick()\n        nextTick(flushQueue);\n    }\n\n}\nfunction flushCallbacks() {\n    callbacks.forEach(cb => cb());\n}\nlet callbacks = [];\n//nextTick 实现原理  setTimeout宏任务 比较慢 所以要这么 \nfunction nextTick(cb) { // cb 就是flushQueue\n    callbacks.push(cb);\n    //要异步刷新这个cb\n    //异步分执行顺序的 会先执行promise  mutationObserver  微任务   setTimeout setImmidiate  宏仁任务\n    let timerFunc = () => {\n        flushCallbacks();\n    }\n    if (Promise) { //then是一个异步\n        return Promise.resolve().then(timerFunc);\n    }\n    if (MutationObserver) { //h5 的api  MutationObserver异步执行 文本节点变成2才会执行 timerFunc\n        let observe = new MutationObserver(timerFunc);\n        let textNode = document.createTextNode(1); //观察文本节点 节点的文本内容发生变化 就会执行 timerFunc\n        observe.observe(textNode, { characterData: true });\n        textNode.textContent = 2;\n        return;\n    }\n    if (setImmediate) {\n        return setImmediate(timerFunc); //高版本浏览器执行\n    }\n    setTimeout(timerFunc, 0);\n}\n// Vue.nextTick\n//渲染使用地 计算属性用他  vm.watch\nexport default Watcher;\n//一个属性里 可以放一个渲染watcher  一个watch方法\n//渲染watcher  包含很多Dep \n//vue2.0一个组件定义一个watcher","export const utils = {\n    getValue(vm, expor) { //school.name\n        //console.log(expor, 'expor'); // school.name\n        let keys = expor.split('.');\n        // console.log(keys, 'keys');//['school', 'name']\n        return keys.reduce((memo, current) => { //reduce具备迭代的功能\n            // console.log(memo, current, 'memo, current');\n            memo = memo[current];// memo = vm.school\n            // console.log(memo, 'memo---');\n            return memo; // return vm['school']['name']\n        }, vm); //第一次 memo = vm current school 下一次  memo 就是vm[school]\n    },\n    compilerText(node, vm) { // 编译文本 替换{{}}\n        // console.log(node, 'compilerText');\n        // let //vue.1.0写法  虚拟dom会重写这个过程\\\n        //?:匹配不捕获 不捕获当前的分组\n        //  +至少一个 \n        //  ？ 尽可能少匹配\n        //源码里的模板编译 也是基于正则的  mac下没有\\r  .是任意字符\n        // debugger;  不是很懂 打印不出node.textContent 但是还能匹配 不是很懂。。。\n        //TODO: 不清楚 不是很懂 打印不出node.textContent 但是还能匹配 不是很懂。。。\n\n        if (!node.expr) {\n            node.expr = node.textContent; //给节点增加了一个自定义属性 为了后续的更新\n        }\n    \n        const defalutRe = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\n        //再次设置的时候 花括号已经没有了  变成值了 就没有效果了\n        // console.log(node.expr, node.textContent);\n        node.textContent = node.expr.replace(defalutRe, function (...args) {\n            // console.log(args, 'node.textContent.args');\n            \n            // return utils.getValue(vm, args[1]);\n            return JSON.stringify(utils.getValue(vm, args[1]));\n            // return \n        })\n    }\n}\n\n\n\n\nexport function compiler(node, vm) {\n    let childNodes = node.childNodes;//只有第一层  只有儿子没有孙子\n    // console.log(childNodes, 'childNodes');\n    [...childNodes].forEach(child => { //一种是元素 一种是文本\n        if (child.nodeType == 1) {//1元素 3是文本\n            compiler(child, vm); //编译当前元素的孩子节点\n        } else if (child.nodeType == 3) {\n            utils.compilerText(child, vm);\n        }\n\n    })\n}","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","//主要拦截用户的push shift unshift pop reverse sort splice\n\nimport { observe } from './index';\n\n//先获取老的方法 只改写这7个\nlet oldArrayProtoMethods = Array.prototype;\n//拷贝的原型\nexport let arrayMethods = Object.create(oldArrayProtoMethods);\n\nexport function observerArray(inserted) {//要循环数组对数组每项观测\n    for(let i = 0; i< inserted.length; i++) {\n        // console.log(inserted[i], 'inserted[i]');\n        observe(inserted[i]);\n    }\n \n}\n\nexport function dependArray(value) {//要循环数组对数组每项观测\n    for(let i = 0; i< value.length; i++) {\n        // console.log(inserted[i], 'inserted[i]');\n        let currentItem = value[i];\n        currentItem.__ob__ && currentItem.__ob__.dep.depend();\n        if (Array.isArray(currentItem)) {\n            dependArray(currentItem);\n        }\n\n    }\n \n}\nlet methods = [\n    'push', \n    'shift',\n    'unshift',\n    'pop',\n    'reverse',\n    'sort',\n    'splice'\n]\nmethods.forEach(method => {\n    arrayMethods[method] = function(...args) { // 函数劫持 切片编程\n        \n        let r = oldArrayProtoMethods[method].apply(this, args);\n        //如果新增的属性也是对象 还要继续观察\n        let inserted;\n        // console.log(args, 'args---');\n        switch(method){\n            case 'push':\n            case 'unshift':\n                inserted = args;\n                break;\n            case 'splice':\n                //获取数组新增的内容\n                inserted = args.slice(2);//获取splcie新增的内容\n            default:\n                break;\n        }\n        // console.log(inserted, 'inserted----');\n        if (inserted) observerArray(inserted);\n        this.__ob__.dep.notify();//通知视图更新\n        return r;\n        // console.log('调用了数组更新的方法');\n    }\n})\n","\nimport {observe} from './index'\nimport {arrayMethods} from './array'\nimport {dependArray} from './array'\nimport {observerArray} from './array'\nimport Dep from './dep';\nexport function definReative(data,key,value) { //定义响应式数据 \n    //vue不支持ie8 ie8以下\n    //如果value依旧是一个对象的话 需要深度观察\n    let childOb = observe(value);//递归\n    //相同的属性 用的是相同的dep\n    let dep =new Dep();//这里收集wactcher  每个属性都增加一个dep实例  \n    Object.defineProperty(data, key, { //data = {arr:[1,2,{a:3}]}\n        // **依赖收集\n        get() { //只要对这个属性进行了取值操作，就会将当前的watcher存入进去\n            // console.log('获取数据');\n            // debugger;\n            if(Dep.target) {//\n                //我们希望存入的watch不重复 如果重复对造成多次渲染\n                // dep.addSub(Dep.target);\n                dep.depend(); //让dep存watch 我还希望这个watch中也存放dep  实现一对多的关系\n                if (childOb) { //数组的依赖收集\n                    childOb.dep.depend(); //数组也收集了当前的渲染watch\n                    dependArray(value);//收集儿子的依赖\n                }\n            }\n            return value\n        },\n        //** 通知依赖更新 */\n        set(newVal) {\n            // console.log('设置数据');\n            if (newVal === value) return;\n            observe(newVal);\n            value = newVal;\n            dep.notify();\n        }\n    })\n\n}\n\n\n\n\nclass Observer {\n    constructor(data){\n        // console.log('observer', data);\n        //用户的数据重新定义\n        this.dep = new Dep();//此dep专门为数组而设定\n        //每个对象 包括数组都有一个——ob_属性 返回当前的observer实例\n        Object.defineProperty(data, '__ob__', {\n            get:() => this\n        })\n        if (Array.isArray(data)) {\n            //只能拦截数组的方法  数组里的每一项还需要去观测一下\n            data.__proto__ = arrayMethods;//通过原型链\n            //当调用数组的方法手动通知\n            observerArray(data);\n\n        }else {\n            this.walk(data)\n        }\n       \n    }\n    walk(data) {\n    \n        let keys = Object.keys(data);\n        // console.log(keys);\n        for(let i = 0; i< keys.length; i++) {\n            let key = keys[i];//用户传入的key\n            let value = data[keys[i]];//用户传入的值\n            definReative(data,key,value);\n        }\n    }\n}\nexport default Observer;","\nimport Observer from './observer'\nimport Watcher from './watcher';\nimport Dep from './dep';\n\n\nexport function initState(vm) {\n    let opts = vm.$options;\n    // console.log(opts, 'opts')\n    if (opts.data) {\n        initData(vm);\n    }\n    if (opts.computed) {\n        initComputed(vm, opts.computed);\n    }\n    if (opts.watch) {\n        initDataWatch(vm);\n    }\n}\nexport function observe(data) {\n    if (typeof data !== 'object' || data == null) {\n        return;\n    }\n    //已经被监控过了\n    if (data.__ob__) {\n        return data.__ob__;\n    }\n    return new Observer(data);\n}\nfunction proxy(vm, source, key) {\n    Object.defineProperty(vm,key,{\n        get() {\n            return vm[source][key]\n        },\n        set(newKey) {\n            vm[source][key] = newKey;\n        }\n    })\n}\nfunction initData(vm) { // 将用户传入的数据 通过defineProperty重新定义\n    let data = vm.$options.data;  // data.call(vm) 可以把函数的返回值取出来\n    data = vm._data = typeof data === 'function' ? data.call(vm) : data || {};\n\n    for(let key in data) {\n        proxy(vm, '_data', key); //会将vm上的取值操作和赋值操作代理给vm._data属性\n\n    }\n    observe(vm._data);\n\n}\n\n//用书取值时会执行此方法\nfunction createComputedGetter(vm, key) {\n    let watcher = vm._watchersComputed[key]; //这个watch就是我们定义的计算属性watcher\n    return function() {//公主\n        if (watcher) {\n            //如果dirty是false的话 不用计算\n            if (watcher.dirty) { //如果页面取值  dirty true 就会调用Wacther方法\n                watcher.evaluate();\n            }\n            if (Dep.target) { //渲染watcher  计算属性watcher\n                watcher.depend();\n            }\n            return watcher.value;\n        }\n    }\n}\n//计算属性的特点 默认不执行 等用户取值时执行 会缓存取值的结果  如果依赖的值变化了  会更新dirty属性 再次取值时 可以重新求新值\n\n//watch不能用在模板里 监控的逻辑Wathcher\n//渲染watcher 用户watcher  计算属性watcher\n\nfunction initComputed(vm, computed) {\n    let watchers = vm._watchersComputed =  Object.create(null); // 创建存储计算属性的watcher对象\n    // console.log(watchers, computed, 'computed----')\n    for(let key in computed) { // \n      \n        let userDef = computed[key];\n        // console.log(key, userDef, 'key----userDef')\n        watchers[key] = new Watcher(vm, userDef,()=>{},{lazy:true} )\n        Object.defineProperty(vm, key, {\n            get: createComputedGetter(vm, key)\n        });\n    }\n}\nfunction createWatcher(vm, key, handler, opts) {\n    //内部最终也会使用\n    return vm.$watch(key, handler, opts);\n}\nfunction initDataWatch(vm) {\n    let watch = vm.$options.watch; //获取用户传入的watch属性\n    // console.log(vm, 'vm');\n    for(let key in watch) { //msg(){}\n        let userDef = watch[key];\n        let handler = userDef;\n        if (userDef.handler) {\n            handler = userDef.handler\n        }\n\n        createWatcher(vm, key, handler, {immediate:userDef.immediate});\n    }\n}","export function vnode(tag, props,key, children, text) {\n    return {\n        tag, //标签名\n        props,//标签的属性\n        key,\n        children,\n        text\n    }\n}","import {vnode} from './create-element'\nexport default function h(tag, props, ...children) {\n    let key = props.key;\n    delete props.key; //属性中不包括key属性\n    children = children.map(child => {\n        if (typeof child === 'object') {\n            return child;\n        }else {\n            return vnode(undefined, undefined,undefined, undefined, child);\n        }\n    })\n    return vnode(tag, props,key, children);\n    \n}\n","//除了第一次初始化渲染之外 还要做比对操作\nexport function render(vnode, container) {  //让虚拟节点渲染成真实节点\n    // console.log(vnode, container);\n    let el = createElm(vnode);\n    // console.log(el, 'el---')\n    container.appendChild(el);\n\n    //递归创建\n}\n//创建真实节点\nfunction createElm(vnode) {\n    let { tag, children, key, props, text } = vnode;\n    if (typeof tag === 'string') {\n        //标签 一个虚拟节点对应着真实节点\n        vnode.el = document.createElement(tag);\n        upadteProperties(vnode); //更新属性\n        children.forEach(child => { //child是虚拟节点\n            return render(child, vnode.el); //递归渲染\n        })\n    } else {\n        //文本\n        vnode.el = document.createTextNode(text);\n    }\n    return vnode.el;\n}\n//更新属性也会调用此方法 {id:'a'}\nfunction upadteProperties(vnode, oldProps = {}) {\n    console.log(vnode, oldProps, 'oldProps---')\n    let newProps = vnode.props || {};//获取老节点的属性\n\n    let el = vnode.el; //当前的真实节点\n    //我要考虑一下以前有没有、\n    //如果下次更新时  我应该用新的属性 来更新老的节点\n    //如果老的中有属性 新的中没有\n\n    let newStyle = newProps.style || {};\n    let oldStyle = oldProps.style || {};\n    console.log(newStyle, oldStyle, 'style---')\n    //稍后会用这个更新操作 主要的作用就是根据\n    // 新的虚拟节点 来修改dom元素\n    for (let key in oldStyle) {\n        if (!newStyle[key]) {\n            el.style[key] = '' //如果没有直接 删除dom上的属性\n        }\n    }\n\n    for (let key in oldProps) {\n        if (!newProps[key]) {\n            delete el[key]; //如果没有直接 删除dom上的属性\n        }\n    }\n    for (let key in newProps) {\n        if (key === 'style') { //如果是？style需要再次遍历\n            for (let styleName in newProps.style) {\n                console.log(styleName, 'styleName');\n                el.style[styleName] = newProps.style[styleName]\n            }\n\n        } else if (key === 'class') {\n            el.className = newProps.class;\n        } else { //给这个元素添加属性 值就是对应的值\n            el[key] = newProps[key];\n        }\n\n    }\n}\n//对比标签  \nexport function patch(oldVnode, newVnode) {\n    // console.log(oldVnode, newVnode, 'oldVnode, newVnode');\n    //1)先比对标签一样不一样\n    if (oldVnode.tag !== newVnode.tag) {\n        //必须拿到当前节点的父亲 才能操作替换自己\n        oldVnode.el.parentNode.replaceChild(createElm(newVnode), oldVnode.el);\n    }\n    //2)比较文本  标签一样 可能都是undefind\n    // console.log(oldVnode.tag, 'tag');\n    if (!oldVnode.tag) { //文本节点\n        // console.log(oldVnode.text, newVnode.text, 'oldVnode.text');\n        if (oldVnode.text !== newVnode.text) {\n            console.log(oldVnode.el, newVnode.text);\n            oldVnode.el.textContent = newVnode.text; //文本节点\n        }\n    }\n    //3)标签一样 可能属性不一样\n    let el = newVnode.el = oldVnode.el; //标签一样复用\n    // console.log(el, 'el---el')\n    // console.log( oldVnode.props, ' oldVnode.props')\n    upadteProperties(newVnode, oldVnode.props);\n    //必须要有一个根节点\n    //4)比较孩子\n    let oldChildren = oldVnode.children || [];\n    let newChildren = newVnode.children || [];\n\n    //老的有孩子 新的有孩子 updateChildren\n    console.log(oldChildren.length, newChildren.length);\n    if (oldChildren.length > 0 && newChildren.length > 0) {\n        updateChildren(el, oldChildren, newChildren);\n    } else if (oldChildren.length > 0) {\n        //老的有孩子 新的没孩子\n        //  console.log('新的没有孩子')\n        el.innerHTML = '';\n    } else if (newChildren.length > 0) {\n        //老的没孩子 新的有孩子\n        for (let i = 0; i < newChildren.length; i++) {\n            let child = newChildren[i];\n            el.appendChild(createElm(child));\n        }\n    }\n    return el;\n\n}\nfunction updateChildren(parent, oldChildren, newChildren) {\n    //vue增加了很多优化策略 \n    //向后面添加  插入dom 比较  4 个变成 5个  \n    //双指针实现\n    let oldStartIndex = 0;\n    let oldStartVnode = oldChildren[0];\n    let oldEndIndex = oldChildren.length - 1;\n    let oldEndVnode = oldChildren[oldEndIndex];\n\n    let newStartIndex = 0;\n    let newStartVnode = newChildren[0];\n    let newEndIndex = newChildren.length - 1;\n    let newEndVnode = newChildren[newEndIndex];\n    function makeIndexByKey(children) {\n        let map = {};\n        children.forEach((item, index) => {\n            map[item.key] = index;\n        })\n        return map;\n    }\n    let map = makeIndexByKey(oldChildren);\n    console.log(map, 'map');\n    while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {\n        //先比较前面是否一样 再从后面比较是否一样\n        if (!oldStartVnode) {\n            oldStartVnode = oldChildren[++oldStartIndex]\n        } else if (!oldEndVnode) {\n            oldEndVnode = oldChildren[--oldEndIndex];\n        } else if (isSameNode(oldStartVnode, newStartVnode)) {\n            //向后插\n            // 先比较前面是否一样\n            patch(oldStartVnode, newStartVnode);//用新的属性更新老的属性\n            // oldStartIndex++;\n            // console.log(oldStartIndex++, 'oldStartIndex++;');\n            // console.log(++oldStartIndex, '++oldStartIndex;');\n            oldStartVnode = oldChildren[++oldStartIndex];\n            newStartVnode = newChildren[++newStartIndex]\n        } else if (isSameNode(oldEndVnode, newEndVnode)) {\n            // 再从后面比较是否一样\n            //向前插入\n            patch(oldEndVnode, newEndVnode);//用新的属性更新老的属性\n            oldEndVnode = oldChildren[--oldEndIndex];\n            newEndVnode = newChildren[--newEndIndex];\n        } else if (isSameNode(oldStartVnode, newEndVnode)) {\n            //DCBA  倒叙\n            //老的指针跟新的最后的指针比较  不一样就向后移动  新的向前 老的向后\n            patch(oldStartVnode, newEndVnode);//用新的属性更新老的属性\n            parent.insertBefore(oldStartVnode.el, oldEndVnode.el.nextSibling);\n            oldStartVnode = oldChildren[++oldStartIndex];\n            newEndVnode = newChildren[--newEndIndex];\n        } else if (isSameNode(oldEndVnode, newStartVnode)) {\n            //DABC 老的尾比新的头 老的尾巴移动到老的头前面\n            // debugger;\n            patch(oldEndVnode, newStartVnode);//用新的属性更新老的属性\n            parent.insertBefore(oldEndVnode.el, oldStartVnode.el);\n            oldEndVnode = oldChildren[--oldEndIndex];\n            newStartVnode = newChildren[++newStartIndex];\n        } else {\n            //两个列表  乱序不复用\n            //会先拿新节点的第一项 去老节点中匹配 如果匹配不到 直接将这个节点插入到\n            //老节点的开头的前面 如果能查到直接移动老节点 \n            //可能老节点中还有剩余 则直接删除\n            let moveIndex = map[newStartVnode.key];\n            if (moveIndex == undefined) {\n                parent.insertBefore(createElm(newStartVnode), oldStartVnode.el);\n            } else {\n                //我要移动这个元素\n                let moveVnode = oldChildren[moveIndex];\n                oldChildren[moveIndex] = undefined;\n                parent.insertBefore(moveVnode.el, oldStartVnode.el);\n                patch(moveVnode, newStartVnode);\n\n            }\n            //要将新节点的指针向后移动\n            newStartVnode = newChildren[++newStartIndex];\n        }\n\n        //倒叙和正序\n    }\n    if (newStartIndex <= newEndIndex) {\n        for (let i = newStartIndex; i <= newEndIndex; i++) {\n            //可能是inserBefore  插入的第二个参数是个null 等价于apendchild\n            // parent.appendChild(createElm(newChildren[i]));\n            //参考节点\n            let ele = newChildren[newEndIndex + 1] == null ? null : newChildren[newEndIndex + 1].el;\n            parent.insertBefore(createElm(newChildren[i]), ele);\n        }\n    }\n    if (oldStartIndex <= oldEndIndex) {\n        for (let i = oldStartIndex; i <= oldEndIndex; i++) {\n            let child = oldChildren[i];\n            if (child != undefined) {\n                parent.removeChild(child.el);\n            }\n        }\n    }\n}\nfunction isSameNode(oldNode, newNode) {\n    return (oldNode.tag === newNode.tag) && (oldNode.key === newNode.key); //复用真实节点\n}","\nimport { initState } from './observe'\nimport Watcher from './observe/watcher';\nimport { utils, compiler } from './utils'\nimport {render, h, patch} from './vdom'\n// import { Compiler } from 'webpack';\nfunction Vue(options) {\n    this._init(options);//初始化vue 并且将用户选项传入\n}\nVue.prototype._init = function (options) {\n    //vue中初始化\n    let vm = this;\n    vm.$options = options;\n    // mvvm原理 需要数据重新初始化\n    initState(vm);//data computed  watch\n    //初始化工作\n    if (vm.$options.el) {\n        vm.$mount();\n    }\n}\n//渲染页面 将组建挂载\nfunction query(el) {\n    if (typeof el === 'string') {\n        return document.querySelector(el);\n    }\n    return el;\n}\n\nVue.prototype._update = function (vnode) {\n    console.log('更新操作', '替换真实的dom');\n    // 将用户传入的视图 去更新视图\n    let vm = this;\n    let el = vm.$el;\n    let preVnode = vm.preVnode;\n    console.log(preVnode, 'preVnode');\n    if(!preVnode) {\n        //\n        vm.preVnode = vnode;//把上一次的节点保存起来\n        render(vnode, el);\n    }else {\n        console.log(patch(preVnode, vnode), 'patch(preVnode, vnode)');\n        vm.$el = patch(preVnode, vnode);\n    }\n    // //要循环这个元素 将里面的内容 换成我们的数据  内存的dom 不是真实  \n    // let node = document.createDocumentFragment();\n    // let firstChild;\n    // while (firstChild = el.firstChild) {//每次拿到第一个元素 将这个元素放到文档碎片中 操作好替换真实dom\n    //     node.appendChild(firstChild); //appengChild具有移动的功能能\n    // }\n    // // // console.log('执行');\n    // // console.log(node, 'node');\n    // // //todo文本替换\n    // compiler(node, vm);\n    // el.appendChild(node);\n    //需要匹配{{}}方式来替换\n    //依赖收集  数据变化了  重新渲染\n\n}\nVue.prototype._render = function() {\n    let vm = this;\n    let render = vm.$options.render;//获取用户编写的render方法\n    let vnode = render.call(vm,h);\n    console.log(vnode, 'vnode');\n    return vnode;\n}\nVue.prototype.$mount = function () {\n    let vm = this;\n    let el = vm.$options.el; // 获取元素 //#app\n    el = vm.$el = query(el);//获取当前挂载的节点 vm.$el就是我要挂载的一个元素\n    //渲染 通过watcher 来渲染\n    //渲染watcher 用于渲染的watcher\n    //vue 2.0 组件级别更新  new Vue产生一个组件\n    let updateComponent = () => { // 更新组件 渲染的逻辑\n        vm._update(vm._render());//更新组件\n\n    }\n\n    new Watcher(vm, updateComponent);//渲染watcher\n    //默认我会创建一个渲染watcer 会默认执行\n    //如果数据更新  需要重新渲染\n}\nVue.prototype.$watch = function (expr, handler, opts) {\n    let vm = this;\n    new Watcher(vm, expr, handler, {user: true, ...opts});//用户自己写的一个Watch\n    //默认我会创建一个渲染watcer 会默认执行\n    //如果数据更新  需要重新渲染\n}\nexport default Vue;","// let app = document.getElementById('app');\n//节约性能 先把真实节点 用一个对象来表示出来 再通过对象渲染到页面上\n//前端操作dom的时候 排序  删除\n//比对  diff 新的节点 在生成一个对象 \n//vue 基本不用手动操作dom\n//虚拟dom  只是一个对象\n// for (let key in app) {\n//     console.log(key);\n// }\n// vue template  render\n// {\n//     tag: 'div',\n//         props: { },\n//     children: [{\n//         tag: undefined,\n//         props: undefined,\n//         children: undefined,\n//         text: 'hello'\n//     }]\n// }\n// new Vue({\n//     render(h) {\n//         return h('div', {}, 'hello')\n//     }\n// })\n//初始化  将虚拟节点渲染到页面上\n//<div id=\"container\"><span style=\"color:red\">hello</span>zf</div>\n\nimport {\n    h,\n    render,\n    patch\n} from '../../source/vue/vdom'\nconsole.log(h, 'f');\n//zf 也应该是个对象\nlet oldVnode = h('div', {\n    id: 'container'\n}, h('li', {\n    key: 'a',\n    style: {\n        backgroundColor: 'red',\n        fontSize: '18px'\n    }\n}, 'a'), h('li', {\n    key: 'b',\n    style: {\n        background: 'yellow'\n    }\n}, 'b'), h('li', {\n    key: 'c',\n    style: {\n        background: 'pink'\n    }\n}, 'c'), h('li', {\n    key: 'd',\n    style: {\n        background: 'orange'\n    }\n}, 'd'));\n// let oldVnode = h('div', {\n//     id: 'container',\n//     key: 1,\n//     class: 'red'\n// });\nconsole.log(oldVnode, 'oldVnode');\nlet container = document.getElementById('app');\n//patchVnode 用新的虚拟节点与老的节点做对比 来更新真实dom元素\nrender(oldVnode, container);\nlet newVnode = h('div', {\n    id: 'aa',\n    style: {\n        background: 'pink',\n        fontSize: '18px'\n    }\n}, h('li', {\n    key: 'e',\n    style: {\n        background: 'red'\n    }\n}, 'e'), h('li', {\n    key: 'a',\n    style: {\n        background: 'yellow'\n    }\n}, 'a'), h('li', {\n    key: 'f',\n    style: {\n        background: 'hotpink'\n    }\n}, 'f'), h('li', {\n    key: 'c',\n    style: {\n        background: 'orange'\n    }\n}, 'c'), h('li', {\n    key: 'n',\n    style: {\n        background: 'orange'\n    }\n}, 'n'));\n// let newVnode = h('div', {\n//     id: 'aa',\n//     style: {\n//         background: 'pink'\n//     }\n// });\n//\nsetTimeout(() => {\n    console.log(newVnode, 'newVnode');\n    patch(oldVnode, newVnode);\n}, 1000);","import Vue from 'vue';\nimport '../src/history/index2'\nlet vm = new Vue({\n    el:'#app',\n    data() {\n        return {msg:'hello zf'}\n    },\n    render(h){ //内部  将render方法中的this  变成当前实例\n        console.log('执行用户传过来的render', h)\n        return h('p',{id:'a'}, this.msg)\n    }\n})\nsetTimeout(() => {\n vm.msg = 'zouyu';\n},1000)"],"sourceRoot":""}