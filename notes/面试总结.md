前端面试题

setTimeout面试题

蒙奇·D·伊丽莎白 2019-05-08 01:51:08  198  收藏
分类专栏： JAVASCRIPT基础 JavaScript常见面试题
版权
一.考察闭包

// 输出全为10

for(var i=0;i<10;i++){

   setTimeout(function(){

       console.log(i);

   },50);

}

 

答1：使用闭包

for(var i=0;i<10;i++){

    (function(i){
     
        setTimeout(function(){
     
        console.log(i);
     
        },50);
     
    })(i);

}
答2.使用ES6块级作用域

for (let i = 0; i < 5; i++) {

setTimeout(() => {

console.log(i);

}, 1000);

}


二、考察异步

问下面console.log的顺序

var arr = [1000,2000,1000];

for (let j = 0; j < arr.length; j++) {

setTimeout(() => {

console.log(j);

}, arr[j]);

}

答：

0,2,1



 

问：如何使上面console.log按顺序执行？

答：使用递归


var i = 0; 
function isfun() {  
     //your code here 把逻辑写在settimeout里，用递归的方式
    //-----
    console.log(i);
    let docs = [1000, 2000, 1000];
    (++i < 3) && setTimeout("isfun()", docs[i - 1]);    
    
    /*或者通俗点这样写
    i++;
    if(i<30){
        setTimeout("isfun()", 3000);
    }
    */
}




改进：减少全局变量

function isfun2(k = 0) {   
    //your code here 把逻辑写在settimeout里，用递归的方式
    //-----
    console.log(k);
    let docs = [1000, 2000, 1000];
    (++k < 3) && setTimeout(() => {
        isfun2(k)
    }, docs[i - 1]);

    /*或者通俗点这样写
    i++;
    if(i<30){
        setTimeout("isfun()", 3000);
    }
    */
}
三、编程题

题目：实现一个类，使每隔指定的秒数执行对应的console.log

new Queue()

.task(() => {

console.log(1)

}, 1000)

.task(() => {

console.log(2)

}, 2000)

.task(() => {

console.log(3)

}, 1000)

.run()

答：

class Queue {
    args = [];
    _self = this;
    task(fn,time) {
        this.args.push([fn,time]);
        return this._self;
    };
    run(k = 0) { 
        let that = this;
        that.args[k][0]();
        (++k < that.args.length) && setTimeout(() => {
            that.run(k)
        }, that.args[k][1]);

    }

}
————————————————
版权声明：本文为CSDN博主「蒙奇·D·伊丽莎白」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/xif3681/article/details/89944048

### 实现 new 方法

```
复制/*
* 1.创建一个空对象
* 2.链接到原型
* 3.绑定this值
* 4.返回新对象
*/
// 第一种实现
function createNew() {
    let obj = {}  // 1.创建一个空对象

    let constructor = [].shift.call(arguments)  
    // let [constructor,...args] = [...arguments]  

    obj.__proto__ = constructor.prototype  // 2.链接到原型

    let result = constructor.apply(obj, arguments)  // 3.绑定this值
    // let result = constructor.apply(obj, args)   

    return typeof result === 'object' ? result : obj  // 4.返回新对象
}

function People(name,age) {
    this.name = name
    this.age = age
}

let peo = createNew(People,'Bob',22)
console.log(peo.name)
console.log(peo.age)
```

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11294541.html#_labelTop)

### 实现 Promise

```
复制// 未添加异步处理等其他边界情况
// ①自动执行函数，②三个状态，③then
class Promise {
  constructor (fn) {
    // 三个状态
    this.state = 'pending'
    this.value = undefined
    this.reason = undefined
    let resolve = value => {
      if (this.state === 'pending') {
        this.state = 'fulfilled'
        this.value = value
      }
    }
    let reject = value => {
      if (this.state === 'pending') {
        this.state = 'rejected'
        this.reason = value
      }
    }
    // 自动执行函数
    try {
      fn(resolve, reject)
    } catch (e) {
      reject(e)
    }
  }
  // then
  then(onFulfilled, onRejected) {
    switch (this.state) {
      case 'fulfilled':
        onFulfilled(this.value)
        break
      case 'rejected':
        onRejected(this.value)
        break
      default:
    }
  }
}
```

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11294541.html#_labelTop)

### 实现一个 call 函数

```
复制// 思路：将要改变this指向的方法挂到目标this上执行并返回
Function.prototype.mycall = function (context) {
  if (typeof this !== 'function') {
    throw new TypeError('not funciton')
  }
  context = context || window
  context.fn = this
  let arg = [...arguments].slice(1)
  let result = context.fn(...arg)
  delete context.fn
  return result
}
```

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11294541.html#_labelTop)

### 实现一个 apply 函数

```
复制// 思路：将要改变this指向的方法挂到目标this上执行并返回
Function.prototype.myapply = function (context) {
  if (typeof this !== 'function') {
    throw new TypeError('not funciton')
  }
  context = context || window
  context.fn = this
  let result
  if (arguments[1]) {
    result = context.fn(...arguments[1])
  } else {
    result = context.fn()
  }
  delete context.fn
  return result
}
```

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11294541.html#_labelTop)

### 实现一个 bind 函数

```
复制// 思路：类似call，但返回的是函数
Function.prototype.mybind = function (context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  let _this = this
  let arg = [...arguments].slice(1)
  return function F() {
    // 处理函数使用new的情况
    if (this instanceof F) {
      return new _this(...arg, ...arguments)
    } else {
      return _this.apply(context, arg.concat(...arguments))
    }
  }
}
```

更多介绍：[bind方法的实现](https://www.jianshu.com/p/9d75886102a7)

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11294541.html#_labelTop)

### 浅拷贝、深拷贝的实现

浅拷贝：

```
复制// 1. ...实现
let copy1 = {...{x:1}}

// 2. Object.assign实现
let copy2 = Object.assign({}, {x:1})
```

深拷贝：

```
复制// 1. JOSN.stringify()/JSON.parse()  
// 缺点：拷贝对象包含 正则表达式，函数，或者undefined等值会失败
let obj = {a: 1, b: {x: 3}}
JSON.parse(JSON.stringify(obj))

// 2. 递归拷贝
function deepClone(obj) {
  let copy = obj instanceof Array ? [] : {}
  for (let i in obj) {
    if (obj.hasOwnProperty(i)) {
      copy[i] = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i]
    }
  }
  return copy
}
```

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11294541.html#_labelTop)

### 实现一个节流函数

```
复制// 思路：在规定时间内只触发一次
function throttle (fn, delay) {
  // 利用闭包保存时间
  let prev = Date.now()
  return function () {
    let context = this
    let arg = arguments
    let now = Date.now()
    if (now - prev >= delay) {
      fn.apply(context, arg)
      prev = Date.now()
    }
  }
}

function fn () {
  console.log('节流')
}
addEventListener('scroll', throttle(fn, 1000))
```

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11294541.html#_labelTop)

### 实现一个防抖函数

```
复制// 思路:在规定时间内未触发第二次，则执行
function debounce (fn, delay) {
  // 利用闭包保存定时器
  let timer = null
  return function () {
    let context = this
    let arg = arguments
    // 在规定时间内再次触发会先清除定时器后再重设定时器
    clearTimeout(timer)
    timer = setTimeout(function () {
      fn.apply(context, arg)
    }, delay)
  }
}

function fn () {
  console.log('防抖')
}
addEventListener('scroll', debounce(fn, 1000))
```

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11294541.html#_labelTop)

### instanceof 的原理

```
复制// 思路：右边变量的原型存在于左边变量的原型链上
function instanceOf(left, right) {
  let leftValue = left.__proto__
  let rightValue = right.prototype
  while (true) {
    if (leftValue === null) {
      return false
    }
    if (leftValue === rightValue) {
      return true
    }
    leftValue = leftValue.__proto__
  }
}
```

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11294541.html#_labelTop)

### 柯里化函数的实现

柯里化函数的定义：**将多参数的函数转换成单参数的形式**。
柯里化函数实现的原理：利用闭包原理在执行可以形成一个不销毁的作用域，然后把需要预先处理的内容都储存在这个不销毁的作用域中，并且返回一个最少参数函数。

第一种：固定传入参数，参数够了才执行

```
复制/**
 * 实现要点：柯里化函数接收到足够参数后，就会执行原函数，那么我们如何去确定何时达到足够的参数呢？
 * 柯里化函数需要记住你已经给过他的参数，如果没给的话，则默认为一个空数组。
 * 接下来每次调用的时候，需要检查参数是否给够，如果够了，则执行fn，没有的话则返回一个新的 curry 函数，将现有的参数塞给他。
 * 
 */
// 待柯里化处理的函数
let sum = (a, b, c, d) => {
  return a + b + c + d
}

// 柯里化函数，返回一个被处理过的函数 
let curry = (fn, ...arr) => {  // arr 记录已有参数
  return (...args) => {   // args 接收新参数
    if (fn.length <= (...arr,...args)) {  // 参数够时，触发执行
      return fn(...arr, ...args)
    } else {  // 继续添加参数
      return curry(fn, [...arr, ...args])
    }
  }
}

var sumPlus = curry(sum)
sumPlus(1)(2)(3)(4)
sumPlus(1, 2)(3)(4)
sumPlus(1, 2, 3)(4)
```

第二种：不固定传入参数，随时执行

```
复制/**
 * 当然了，柯里化函数的主要作用还是延迟执行，执行的触发条件不一定是参数个数相等，也可以是其他的条件。
 * 例如参数个为0的情况，那么我们需要对上面curry函数稍微做修改
 */
// 待柯里化处理的函数
let sum = arr => {
  return arr.reduce((a, b) => {
    return a + b
  })
}

let curry = (fn, ...arr) => {  // arr 记录已有参数
  return (...args) => {  // args 接收新参数
    if (args.length === 0) {  // 参数为空时，触发执行
      return fn(...arr, ...args)
    } else {  // 继续添加参数
      return curry(fn, ...arr, ...args)
    }
  }
}

var sumPlus = curry(sum)
sumPlus(1)(2)(3)(4)()
sumPlus(1, 2)(3)(4)()
sumPlus(1, 2, 3)(4)()
```

参考链接：[js如何用一句代码实现函数的柯里化（ES6）](https://www.jianshu.com/p/c87242cd2f6c)

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11294541.html#_labelTop)

### Object.create 的基本实现原理

```
复制// 思路：将传入的对象作为原型
function create(obj) {
  function F() {}
  F.prototype = obj
  return new F()
}
```

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11294541.html#_labelTop)

### 实现一个基本的 Event Bus

```
复制// 组件通信，一个触发与监听的过程
class EventEmitter {
  constructor () {
    // 存储事件
    this.events = this.events || new Map()
  }
  // 监听事件
  addListener (type, fn) {
    if (!this.events.get(type)) {
      this.events.set(type, fn)
    }
  }
  // 触发事件
  emit (type) {
    let handle = this.events.get(type)
    handle.apply(this, [...arguments].slice(1))
  }
}

// 测试
let emitter = new EventEmitter()
// 监听事件
emitter.addListener('ages', age => {
  console.log(age)
})
// 触发事件
emitter.emit('ages', 18)  // 18
```

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11294541.html#_labelTop)

### 实现一个双向数据绑定

```
复制let obj = {}
let input = document.getElementById('input')
let span = document.getElementById('span')
// 数据劫持
Object.defineProperty(obj, 'text', {
  configurable: true,
  enumerable: true,
  get() {
    console.log('获取数据了')
  },
  set(newVal) {
    console.log('数据更新了')
    input.value = newVal
    span.innerHTML = newVal
  }
})
// 输入监听
input.addEventListener('keyup', function(e) {
  obj.text = e.target.value
})
```

详细的实现见：[这应该是最详细的响应式系统讲解了](https://juejin.im/post/5d26e368e51d4577407b1dd7)

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11294541.html#_labelTop)

### 实现一个简单路由

```
复制// hash路由
class Route{
  constructor(){
    // 路由存储对象
    this.routes = {}
    // 当前hash
    this.currentHash = ''
    // 绑定this，避免监听时this指向改变
    this.freshRoute = this.freshRoute.bind(this)
    // 监听
    window.addEventListener('load', this.freshRoute, false)
    window.addEventListener('hashchange', this.freshRoute, false)
  }
  // 存储
  storeRoute (path, cb) {
    this.routes[path] = cb || function () {}
  }
  // 更新
  freshRoute () {
    this.currentHash = location.hash.slice(1) || '/'
    this.routes[this.currentHash]()
  }
}
```

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11294541.html#_labelTop)

### 实现懒加载

```
复制<ul>
  <li><img src="./imgs/default.png" data="./imgs/1.png" alt=""></li>
  <li><img src="./imgs/default.png" data="./imgs/2.png" alt=""></li>
  <li><img src="./imgs/default.png" data="./imgs/3.png" alt=""></li>
  <li><img src="./imgs/default.png" data="./imgs/4.png" alt=""></li>
  <li><img src="./imgs/default.png" data="./imgs/5.png" alt=""></li>
  <li><img src="./imgs/default.png" data="./imgs/6.png" alt=""></li>
  <li><img src="./imgs/default.png" data="./imgs/7.png" alt=""></li>
  <li><img src="./imgs/default.png" data="./imgs/8.png" alt=""></li>
  <li><img src="./imgs/default.png" data="./imgs/9.png" alt=""></li>
  <li><img src="./imgs/default.png" data="./imgs/10.png" alt=""></li>
</ul>
复制let imgs =  document.querySelectorAll('img')
// 可视区高度
let clientHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
function lazyLoad () {
  // 滚动卷去的高度
  let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
  for (let i = 0; i < imgs.length; i ++) {
    // 图片在可视区冒出的高度
    let x = clientHeight + scrollTop - imgs[i].offsetTop
    // 图片在可视区内
    if (x > 0 && x < clientHeight+imgs[i].height) {
      imgs[i].src = imgs[i].getAttribute('data')
    }
  }
}
// addEventListener('scroll', lazyLoad) or setInterval(lazyLoad, 1000)
```

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11294541.html#_labelTop)

### rem 基本设置

```
复制// 提前执行，初始化 resize 事件不会执行
setRem()
// 原始配置
function setRem () {
  let doc = document.documentElement
  let width = doc.getBoundingClientRect().width
  let rem = width / 75
  doc.style.fontSize = rem + 'px'
}
// 监听窗口变化
addEventListener("resize", setRem)
```

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11294541.html#_labelTop)

### 手写实现 AJAX

```
复制// 1. 简单流程

// 实例化
let xhr = new XMLHttpRequest()
// 初始化
xhr.open(method, url, async)
// 发送请求
xhr.send(data)
// 设置状态变化回调处理请求结果
xhr.onreadystatechange = () => {
  if (xhr.readyStatus === 4 && xhr.status === 200) {
    console.log(xhr.responseText)
  }
}

// 2. 基于promise实现

function ajax (options) {
  // 请求地址
  const url = options.url
  // 请求方法
  const method = options.method.toLocaleLowerCase() || 'get'
  // 默认为异步true
  const async = options.async
  // 请求参数
  const data = options.data
  // 实例化
  const xhr = new XMLHttpRequest()
  // 请求超时
  if (options.timeout && options.timeout > 0) {
    xhr.timeout = options.timeout
  }
  // 返回一个Promise实例
  return new Promise ((resolve, reject) => {
    xhr.ontimeout = () => reject && reject('请求超时')
    // 监听状态变化回调
    xhr.onreadystatechange = () => {
      if (xhr.readyState == 4) {
        // 200-300 之间表示请求成功，304资源未变，取缓存
        if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
          resolve && resolve(xhr.responseText)
        } else {
          reject && reject()
        }
      }
    }
    // 错误回调
    xhr.onerror = err => reject && reject(err)
    let paramArr = []
    let encodeData
    // 处理请求参数
    if (data instanceof Object) {
      for (let key in data) {
        // 参数拼接需要通过 encodeURIComponent 进行编码
        paramArr.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key]))
      }
      encodeData = paramArr.join('&')
    }
    // get请求拼接参数
    if (method === 'get') {
      // 检测url中是否已存在 ? 及其位置
      const index = url.indexOf('?')
      if (index === -1) url += '?'
      else if (index !== url.length -1) url += '&'
      // 拼接url
      url += encodeData
    }
    // 初始化
    xhr.open(method, url, async)
    // 发送请求
    if (method === 'get') xhr.send(null)
    else {
      // post 方式需要设置请求头
      xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded;charset=UTF-8')
      xhr.send(encodeData)
    }
  })
}
```

### Vue 双向绑定原理  怎么写一个组件

考察v-model在组件的运用 不只是用在input上

```js
数据双向绑定
父组件
<child v-model="data">
    
    child 子组件
    props: {
        value:{
            type: Array,
                default:() => [] // valule 必须为数组类型
        }
    }，
    data() {
        return {
            currentValue: this.value // 组件要找一个值接收value  vue 规定不能改子组件的值
        }
    }，
    watch: {
        value(val) {
            this.currentValue = val;
        },
          currentValue(val) {
              this.$emit('input', val)
          }  
    }
至此  组件实现了双向绑定  父组件的值跟子组件的值同步变化  编写组件的时候都采用此方法

还有个重点this.$set的应用
vue 不能监听arr[1] = '1' 这种直接操作数组索引产生的变化  页面虽然是双向绑定的 但是vue监听不到
还有就是vue 监听不到对象新增加的值  也需要用this.$set 可百度增加了解，这个很重要，写代码的时候经常用到，面试也会问
```



mvvm 双向绑定，采用**数据劫持结合发布者-订阅者模式**的方式，通过 `Object.defineProperty()` 来劫持各个属性的 setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
![双向绑定原理](https://img2018.cnblogs.com/blog/1062623/201908/1062623-20190804115239165-1926232443.png)

**几个要点：**
1、实现一个数据监听器 Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者
2、实现一个指令解析器 Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数
3、实现一个 Watcher，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图
4、mvvm 入口函数，整合以上三者

**具体步骤：**

1. 需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter
   这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化
2. compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
3. Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:
   - 在自身实例化时往属性订阅器(dep)里面添加自己
   - 自身必须有一个 update() 方法
   - 待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。
4. MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过Observer来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据 model 变更的双向绑定效果。

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11258895.html#_labelTop)

### 描述下 vue 从初始化页面--修改数据--刷新页面 UI 的过程？

   当 Vue 进入初始化阶段时，一方面 Vue 会遍历 data 中的属性，并用 Object.defineProperty 将它转化成 getter/setter 的形式，实现数据劫持(暂不谈 Vue3.0 的 Proxy)；另一方面，Vue 的指令编译器 Compiler 对元素节点的各个指令进行解析，初始化视图，并订阅 Watcher 来更新试图，此时 Watcher 会将自己添加到消息订阅器 Dep 中，此时初始化完毕。
   当数据发生变化时，触发 Observer 中 setter 方法，立即调用 Dep.notify(),Dep 这个数组开始遍历所有的订阅者，并调用其 update 方法，Vue 内部再通过 diff 算法，patch 相应的更新完成对订阅者视图的改变。

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11258895.html#_labelTop)

### 你是如何理解 Vue 的响应式系统的?

![vue响应系统](https://img2018.cnblogs.com/blog/1062623/201908/1062623-20190808112924933-354933996.jpg)
响应式系统简述:

- 任何一个 Vue Component 都有一个与之对应的 Watcher 实例
- Vue 的 data 上的属性会被添加 getter 和 setter 属性
- 当 Vue Component render 函数被执行的时候, data 上会被 触碰(touch), 即被读, getter 方法会被调用, 此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这一过程被称为依赖收集)
- data 被改动时（主要是用户操作）, 即被写, setter 方法会被调用, 此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11258895.html#_labelTop)

### 虚拟 DOM 实现原理

- 虚拟DOM本质上是JavaScript对象,是对真实DOM的抽象
- 状态变更时，记录新树和旧树的差异
- 最后把差异更新到真正的dom中

> 详细实现见 [面试官: 你对虚拟DOM原理的理解?](https://user-gold-cdn.xitu.io/2019/8/1/16c49afec13e0416)

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11258895.html#_labelTop)

### 既然 Vue 通过数据劫持可以精准探测数据变化,为什么还需要虚拟 DOM 进行 diff 检测差异?

考点: Vue 的变化侦测原理
前置知识: 依赖收集、虚拟 DOM、响应式系统
现代前端框架有两种方式侦测变化，一种是pull，一种是push

pull: 其代表为React，我们可以回忆一下React是如何侦测到变化的,我们通常会用setStateAPI显式更新，然后React会进行一层层的Virtual Dom Diff操作找出差异，然后Patch到DOM上，React从一开始就不知道到底是哪发生了变化，只是知道「有变化了」，然后再进行比较暴力的Diff操作查找「哪发生变化了」，另外一个代表就是Angular的脏检查操作。

push: Vue的响应式系统则是push的代表，当Vue程序初始化的时候就会对数据data进行依赖的收集，一但数据发生变化,响应式系统就会立刻得知。因此Vue是一开始就知道是「在哪发生变化了」，但是这又会产生一个问题，如果你熟悉Vue的响应式系统就知道，通常一个绑定一个数据就需要一个Watcher，一但我们的绑定细粒度过高就会产生大量的Watcher，这会带来内存以及依赖追踪的开销，而细粒度过低会无法精准侦测变化,因此Vue的设计是选择中等细粒度的方案,在组件级别进行push侦测的方式,也就是那套响应式系统,通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行Virtual Dom Diff获取更加具体的差异，而Virtual Dom Diff则是pull操作，Vue是push+pull结合的方式进行变化侦测的。

[Vue和React的视图更新机制对比](https://blog.csdn.net/csdn_haow/article/details/89915908)

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11258895.html#_labelTop)

### Vue 中 key 值的作用？

   当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“**就地复用**”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。**key 的作用主要是为了高效的更新虚拟DOM**。

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11258895.html#_labelTop)

### Vue 的生命周期

[vue生命周期详解](https://juejin.im/post/5c6d48e36fb9a049eb3c84ff)

1. `beforeCreate`和`created`
2. `beforeMount`和`mounted`
3. `beforeUpdate`和`updated`
4. `beforeDestory`和`destoryed`
5. `activated`和`deactivated`

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11258895.html#_labelTop)

### Vue 组件间通信有哪些方式?  必须会写

[Vue 组件间通信六种方式](https://juejin.im/post/5cde0b43f265da03867e78d3)

1. props/$emit
2. $emit/$on
3. vuex
4. $attrs/$listeners
5. provide/inject
6. $parent/$children 与 ref

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11258895.html#_labelTop)

### watch、methods 和 computed 的区别?

- watch 为了监听某个响应数据的变化。computed 是自动**监听依赖值**的变化，从而动态返回内容，主要目的是简化模板内的复杂运算。所以区别来源于用法，只是需要动态值，那就用 computed ；需要知道值的改变后执行业务逻辑，才用 watch。
- methods是一个方法，它可以接受参数，而computed 不能，computed 是可以缓存的，methods 不会。computed 可以依赖其他 computed，甚至是其他组件的 data。

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11258895.html#_labelTop)

### vue 中怎么重置 data?

使用Object.assign()，vm.$data可以获取当前状态下的data，vm.$options.data(this)可以获取到组件初始化状态下的data。

```
复制Object.assign(this.$data, this.$options.data(this))  // 注意加this，不然取不到data() { a: this.methodA } 中的this.methodA。
```

> 原因参考：[Vue中的this.$options.data()和this.$data](https://blog.csdn.net/mocoe/article/details/89682022)

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11258895.html#_labelTop)

### 组件中写 name 选项有什么作用？

1. 项目使用 keep-alive 时，可搭配组件 name 进行缓存过滤
2. DOM 做递归组件时需要调用自身 name
3. vue-devtools 调试工具里显示的组见名称是由vue中组件name决定的

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11258895.html#_labelTop)

### vue-router 有哪些钩子函数?

官方文档：[vue-router钩子函数](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#全局前置守卫)

- 全局前置守卫 `router.beforeEach`
- 全局解析守卫 `router.beforeResolve`
- 全局后置钩子 `router.afterEach`
- 路由独享的守卫 `beforeEnter`
- 组件内的守卫 `beforeRouteEnter`、`beforeRouteUpdate`、`beforeRouteLeave`

[前端路由简介以及vue-router实现原理](https://juejin.im/post/5b10b46df265da6e2a08a724)

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11258895.html#_labelTop)

### `route` 和 `router` 的区别是什么？

`route`是“路由信息对象”，包括`path`,`params`,`hash`,`query`,`fullPath`,`matched`,`name`等路由信息参数。
`router`是“路由实例对象”，包括了路由的跳转方法(`push`、`replace`)，钩子函数等。

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11258895.html#_labelTop)

### 说一下 Vue 和 React 的认识，做一个简单的对比

**1.监听数据变化的实现原理不同**

- Vue 通过 getter/setter 以及一些函数的劫持，能精确快速的计算出 Virtual DOM 的差异。这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。
- React 默认是通过比较引用的方式进行的，如果不优化，每当应用的状态被改变时，全部子组件都会重新渲染，可能导致大量不必要的 VDOM 的重新渲染。

   Vue 不需要特别的优化就能达到很好的性能，而对于 React 而言，需要通过 PureComponent/shouldComponentUpdate 这个生命周期方法来进行控制。如果你的应用中，交互复杂，需要处理大量的 UI 变化，那么使用 Virtual DOM 是一个好主意。如果你更新元素并不频繁，那么 Virtual DOM 并不一定适用，性能很可能还不如直接操控 DOM。

   为什么 React 不精确监听数据变化呢？这是因为 Vue 和 React 设计理念上的区别，Vue 使用的是可变数据，而 React 更强调数据的不可变。

**2.数据流的不同**
![cmd-markdown-logo](https://img-blog.csdnimg.cn/20190601094122147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2tpXw==,size_16,color_FFFFFF,t_70)

- Vue 中默认支持双向绑定，组件与 DOM 之间可以通过 v-model 双向绑定。但是，父子组件之间，props 在 2.x 版本是单向数据流
- React 一直提倡的是单向数据流，他称之为 onChange/setState()模式。

   不过由于我们一般都会用 Vuex 以及 Redux 等单向数据流的状态管理框架，因此很多时候我们感受不到这一点的区别了。

**3.模板渲染方式的不同**

在表层上，模板的语法不同

- React 是通过 JSX 渲染模板
- 而 Vue 是通过一种拓展的 HTML 语法进行渲染

在深层上，模板的原理不同，这才是他们的本质区别：

- React 是在组件 JS 代码中，通过原生 JS 实现模板中的常见语法，比如插值，条件，循环等，都是通过 JS 语法实现的
- Vue 是在和组件 JS 代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现

   对这一点，我个人比较喜欢 React 的做法，因为他更加纯粹更加原生，而 Vue 的做法显得有些独特，会把 HTML 弄得很乱。举个例子，说明 React 的好处：react 中 render 函数是支持闭包特性的，所以我们 import 的组件在 render 中可以直接调用。但是在 Vue 中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以我们 import 一个组件完了之后，还需要在 components 中再声明下，这样显然是很奇怪但又不得不这样的做法。

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11258895.html#_labelTop)

### Vue 的 nextTick 的原理是什么？

**1. 为什么需要 nextTick**
   Vue 是异步修改 DOM 的并且不鼓励开发者直接接触 DOM，但有时候业务需要必须对数据更改--刷新后的 DOM 做相应的处理，这时候就可以使用 Vue.nextTick(callback)这个 api 了。

**2. 理解原理前的准备**
   首先需要知道事件循环中宏任务和微任务这两个概念(这其实也是面试常考点)。请阅大佬文章--[彻底搞懂浏览器 Event-loop](https://juejin.im/post/5c947bca5188257de704121d)
常见的宏任务有 script, setTimeout, setInterval, setImmediate, I/O, UI rendering
常见的微任务有 process.nextTick(Nodejs),Promise.then(), MutationObserver;

**3. 理解 nextTick**
   而 nextTick 的原理正是 vue 通过异步队列控制 DOM 更新和 nextTick 回调函数先后执行的方式。如果大家看过这部分的源码，会发现其中做了很多 isNative()的判断，因为这里还存在兼容性优雅降级的问题。可见 Vue 开发团队的深思熟虑，对性能的良苦用心。
如果你比较了解了前面的事件循环原理，推荐你看看这篇文章 请阅大佬文章--[全面解析 Vue.nextTick 实现原理](https://mp.weixin.qq.com/s/mCcW4OYj3p3471ghMBylBw)

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11258895.html#_labelTop)

### Vuex 有哪几种属性?

有五种，分别是 `State`、`Getter`、`Mutation`、`Action`、`Module`

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11258895.html#_labelTop)

### vue 首屏加载优化

##### 1. 把不常改变的库放到 index.html 中，通过 cdn 引入

![index.html](https://img2018.cnblogs.com/blog/1062623/201908/1062623-20190813191312623-1502430740.jpg)
然后找到 build/webpack.base.conf.js 文件，在 module.exports = { } 中添加以下代码

```
复制externals: {
  'vue': 'Vue',
  'vue-router': 'VueRouter',
  'element-ui': 'ELEMENT',
},
```

这样 webpack 就不会把 vue.js, vue-router, element-ui 库打包了。声明一下，我把 main.js 中对 element 的引入删掉了，不然我发现打包后的 app.css 还是会把 element 的 css 打包进去，删掉后就没了。
然后你打包就会发现 vendor 文件小了很多~

##### 2. vue 路由的懒加载

`import`或者`require`懒加载。你打包就会发现，多了很多 1.xxxxx.js；2.xxxxx.js 等等，而 vendor.xxx.js 没了，剩下 app.js 和 manifest.js，而且 app.js 还很小，我这里是 100k 多一点。

##### 3. 不生成 map 文件

找到 config/index.js，修改为 `productionSourceMap: false`

##### 4. vue 组件尽量不要全局引入

##### 5. 使用更轻量级的工具库

##### 6. 开启gzip压缩

这个优化是两方面的，前端将文件打包成.gz文件，然后通过nginx的配置，让浏览器直接解析.gz文件。

##### 7. 首页单独做服务端渲染

如果首页真的有瓶颈，可以考虑用 node 单独做服务端渲染，而下面的子页面仍用 spa 单页的方式交互。
这里不推荐直接用 nuxt.js 服务端渲染方案，因为这样一来增加了学习成本，二来服务端的维护成本也会上升，有时在本机测试没问题，在服务端跑就有问题，为了省心，还是最大限度的使用静态页面较好。

参考链接：
[vue首屏加载优化](https://www.jianshu.com/p/df198914331b)
[vue项目首屏加载优化实战](https://www.cnblogs.com/mianbaodaxia/p/10751453.html)

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11258895.html#_labelTop)

### Vue 3.0 有没有过了解？

   关于Vue 3.0有幸看过尤大的关于3.0版本的[RFC Vue Function-based API RFC](https://zhuanlan.zhihu.com/p/68477600)。大致说了三个点，第一个是关于提出的新API `setup()`函数，第二个说了对于Typescript的支持，最后说了关于替换`Object.defineProperty`为 Proxy 的支持。
   详细说了下关于Proxy代替带来的性能上的提升，因为传统的原型链拦截的方法，无法检测对象及数组的一些更新操作，但使用Proxy又带来了浏览器兼容问题。

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11258895.html#_labelTop)

### vue-cli 替我们做了哪些工作？

首先需要知道 vue-cli 是什么？它是基于 Vue.js 进行快速开发的完整系统，也可以理解成是很多 npm 包的集合。其次，vue-cli 完成的功能有哪些？

> .vue 文件 --> .js 文件
> ES6 语法 --> ES5 语法
> Sass,Less,Stylus --> CSS
> 对 jpg,png,font 等静态资源的处理
> 热更新
> 定义环境变量，区分 dev 和 production 模式
> ...

如果开发者需要补充或修改默认设置，需要在 package.json 同级下新建一个 vue.config.js 文件

css面试题

### 盒模型

```
复制/* 红色区域的大小是多少？200 - 20*2 - 20*2 = 120 */
.box {
    width: 200px;
    height: 200px;
    padding: 20px;
    margin: 20px;
    background: red;
    border: 20px solid black;
    box-sizing: border-box;
}
复制/* 标准模型 */
box-sizing:content-box;
 /*IE模型*/
box-sizing:border-box;
```

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11217590.html#_labelTop)

### 如何实现一个最大的正方形

用 `padding-bottom` 撑开边距

```
复制 section {
    width:100%;
    padding-bottom: 100%;
    background: #333;
}
```

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11217590.html#_labelTop)

### 一行水平居中，多行居左

```
复制<div><span>我是多行文字。我是多行文字。我是多行文字。我是多行文字。我是多行文字。我是多行文字。我是多行文字。我是多行文字。我是多行文字。我是多行文字。</span></div>
<div><span>我是一行文字</span></div>

<style>
div{text-align: center;}
div span{display: inline-block;text-align: left;}
</style>
```

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11217590.html#_labelTop)

### 水平垂直居中

贴上腾讯大佬的一篇文章：[16种方式实现水平居中垂直居中](https://juejin.im/post/58f818bbb123db006233ab2a)

# 两栏布局，左边固定，右边自适应，左右不重叠

flex做自适应布局很容易，但兼容性不好，这里统一不用flex布局

```
复制.left{
    float:left;
    width:300px;
    margin-right: 10px;
    background: red;
}
.right{
    overflow: hidden; /* 创建BFC */
    background: yellow;
}
```

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11217590.html#_labelTop)

### 如何实现左右等高布局

`table`布局兼容性最好，当然`flex`布局的`align-items: stretch;`也行

```
复制<div class="layout">
  <div class="layout left">left</div>
  <div class="layout right">center</div>
</div>

<style>
.layout{
  display: table;
  width: 100%;
}
.layout div{
  display: table-cell;
}
.layout .left{
  width: 50%;
  height: 200px;
  background: red;
}
.layout .right{
  width: 50%;
  background: yellow;
}
</style>
```

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11217590.html#_labelTop)

### 画三角形

```
复制.shape {
	width: 0;
	height: 0;
	border-left: 50px solid transparent;
	border-right: 50px solid transparent;
	border-top: 50px solid transparent;
	border-bottom: 50px solid blue;
	background: white;
}
```

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11217590.html#_labelTop)

### link @import导入css

1. link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS
2. link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载
3. link无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持
4. link支持使用Javascript控制DOM去改变样式；而@import不支持

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11217590.html#_labelTop)

### BFC理解

BFC触发条件：

1. 根元素，即html
2. float的值不为none（默认）
3. position的值为absolute或fixed
4. overflow的值不为visible（默认）
5. display的值为inline-block、table-cell、table-caption

BFC特性：

1. 内部的Box会在垂直方向上一个接一个放置。
2. Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠。
3. 每个元素的margin box 的左边，与包含块border box的左边相接触。
4. BFC的区域不会与float box重叠。（可用于清浮动）
5. BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。
6. 计算BFC的高度时，浮动元素也会参与计算。

### 判断 js 类型的方式

##### 1. typeof

可以判断出'string','number','boolean','undefined','symbol'
但判断 typeof(null) 时值为 'object'; 判断数组和对象时值均为 'object'

##### 2. instanceof

原理是 构造函数的 prototype 属性是否出现在对象的原型链中的任何位置

```
复制function A() {}
let a = new A();
a instanceof A     //true,因为 Object.getPrototypeOf(a) === A.prototype;
```

##### 3. Object.prototype.toString.call()

常用于判断浏览器内置对象,对于所有基本的数据类型都能进行判断，即使是 null 和 undefined

##### 4. Array.isArray()

用于判断是否为数组

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11253403.html#_labelTop)

### ES5 和 ES6 分别几种方式声明变量

ES5 有俩种：`var` 和 `function`
ES6 有六种：增加四种，`let`、`const`、`class` 和 `import`

注意：`let`、`const`、`class`声明的全局变量再也不会和全局对象的属性挂钩

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11253403.html#_labelTop)

### 闭包的概念？优缺点？

闭包的概念：闭包就是能读取其他函数内部变量的函数。

优点：

1. 避免全局变量的污染
2. 希望一个变量长期存储在内存中（缓存变量）

缺点：

1. 内存泄露（消耗）
2. 常驻内存，增加内存使用量

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11253403.html#_labelTop)

### 浅拷贝和深拷贝

- **浅拷贝**

```
复制// 第一层为深拷贝
Object.assign()
Array.prototype.slice()
扩展运算符 ...
```

- **深拷贝**

```
复制JSON.parse(JSON.stringify())
```

递归函数

```
复制function cloneObject(obj) {
  var newObj = {} //如果不是引用类型，直接返回
  if (typeof obj !== 'object') {
    return obj
  }
  //如果是引用类型，遍历属性
  else {
    for (var attr in obj) {
      //如果某个属性还是引用类型，递归调用
      newObj[attr] = cloneObject(obj[attr])
    }
  }
  return newObj
}
```

[如何实现一个深拷贝](https://juejin.im/post/5c45112e6fb9a04a027aa8fe)
[详细解析赋值、浅拷贝和深拷贝的区别](https://juejin.im/post/5c20509bf265da611b585bec)

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11253403.html#_labelTop)

### 数组去重的方法

##### 1.ES6 的 Set

```
复制let arr = [1,1,2,3,4,5,5,6]
let arr2 = [...new Set(arr)]
```

##### 2.reduce()

```
复制let arr = [1,1,2,3,4,5,5,6]
let arr2 = arr.reduce(function(ar,cur) {
  if(!ar.includes(cur)) {
    ar.push(cur)
  }

  return ar
},[])

reduce主要用于数组迭代   相当棒的方法
```

##### 3.filter()

```
复制// 这种方法会有一个问题：[1,'1']会被当做相同元素，最终输入[1]
let arr = [1,1,2,3,4,5,5,6]
let arr2 = arr.filter(function(item,index) {
  // indexOf() 方法可返回某个指定的 字符串值 在字符串中首次出现的位置
  return arr.indexOf(item) === index
})
```

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11253403.html#_labelTop)

4.map() 必须掌握 自行百度

.ind

.findIndex

some 跟foreach的区别是能阻断循环 遇到true 停止循环

### DOM 事件有哪些阶段？谈谈对事件代理的理解

分为三大阶段：捕获阶段--目标阶段--冒泡阶段

事件代理简单说就是：事件不直接绑定到某元素上，而是绑定到该元素的父元素上，进行触发事件操作时(例如'click')，再通过条件判断，执行事件触发后的语句(例如'alert(e.target.innerHTML)')

好处：(1)使代码更简洁；(2)节省内存开销

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11253403.html#_labelTop)

### js 执行机制、事件循环

   JavaScript 语言的一大特点就是单线程，同一个时间只能做一件事。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。JavaScript 语言的设计者意识到这个问题，将所有任务分成两种，一种是**同步任务（synchronous），另一种是异步任务（asynchronous）**，在所有同步任务执行完之前，任何的异步任务是不会执行的。
   当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明：
![js执行机制](https://img2018.cnblogs.com/blog/1062623/201908/1062623-20190804122236943-502816731.jpg)

导图要表达的内容用文字来表述的话：
   同步和异步任务分别进入不同的执行"场所"，同步的进入主线程，异步的进入 Event Table 并注册函数。当**指定的事情完成时**，Event Table 会将这个函数移入 Event Queue。主线程内的任务执行完毕为空，会去 Event Queue 读取对应的函数，进入主线程执行。上述过程会不断重复，也就是常说的 Event Loop(事件循环)。
   我们不禁要问了，那怎么知道主线程执行栈为空啊？js 引擎存在 monitoring process 进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去 Event Queue 那里检查是否有等待被调用的函数。换一张图片也许更好理解主线程的执行过程：

![img](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=3568080110,3758711556&fm=173&app=25&f=JPEG?w=639&h=354&s=5A203C6292FE6588147FCCC40200E0B3)
   上图用文字表述就是：主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）。只要主线程空了，就会去读取"任务队列"，这就是 JavaScript 的运行机制。

   说完 JS 主线程的执行机制，下面说说经常被问到的 JS 异步中 宏任务（macrotasks）、微任务（microtasks）执行顺序。**JS 异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入 Event Queue，然后再执行微任务，将微任务放入 Event Queue，但是，这两个 Queue 不是一个 Queue。当你往外拿的时候先从微任务里拿这个回调函数，然后再从宏任务的 Queue 拿宏任务的回调函数**。如下图：
![JS异步](https://img2018.cnblogs.com/blog/1062623/201908/1062623-20190804122144531-1357636710.jpg)

宏任务：整体代码 script，setTimeout，setInterval

微任务：Promise，process.nextTick

参考链接：[这一次，彻底弄懂 JavaScript 执行机制](https://juejin.im/post/59e85eebf265da430d571f89)

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11253403.html#_labelTop)

### 介绍下 promise.all

   Promise.all()方法将多个Promise实例包装成一个Promise对象（p），接受一个数组（p1,p2,p3）作为参数，数组中不一定需要都是Promise对象，但是一定具有Iterator接口，如果不是的话，就会调用Promise.resolve将其转化为Promise对象之后再进行处理。
   使用Promise.all()生成的Promise对象（p）的状态是由数组中的Promise对象（p1,p2,p3）决定的。

1. 如果所有的Promise对象（p1,p2,p3）都变成fullfilled状态的话，生成的Promise对象（p）也会变成fullfilled状态，
   p1,p2,p3三个Promise对象产生的结果会组成一个数组返回给传递给p的回调函数。
2. 如果p1,p2,p3中有一个Promise对象变为rejected状态的话，p也会变成rejected状态，第一个被rejected的对象的返回值会传递给p的回调函数。
   Promise.all()方法生成的Promise对象也会有一个catch方法来捕获错误处理，但是如果数组中的Promise对象变成rejected状态时，
   并且这个对象还定义了catch的方法，那么rejected的对象会执行自己的catch方法。
   并且返回一个状态为fullfilled的Promise对象，Promise.all()生成的对象会接受这个Promise对象，不会返回rejected状态。

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11253403.html#_labelTop)

### async 和 await

主要考察宏任务和微任务，搭配promise，询问一些输出的顺序

原理：**async 和 await 用了同步的方式去做异步，async 定义的函数的返回值都是 promise，await 后面的函数会先执行一遍，然后就会跳出整个 async 函数来执行后面js栈的代码**

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11253403.html#_labelTop)

### ES6 的 class 和构造函数的区别

class 的写法只是语法糖，和之前 prototype 差不多，但还是有细微差别的，下面看看：

##### 1. 严格模式

类和模块的内部，默认就是严格模式，所以不需要使用`use strict`指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。

##### 2. 不存在提升

类不存在变量提升（hoist），这一点与 ES5 完全不同。

```
复制new Foo(); // ReferenceError
class Foo {}
```

##### 3. 方法默认是不可枚举的

ES6 中的 class，它的方法（包括静态方法和实例方法）默认是不可枚举的，而构造函数默认是可枚举的。细想一下，这其实是个优化，让你在遍历时候，不需要再判断 hasOwnProperty 了

##### 4. class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用。

##### 5. class 必须使用 new 调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用 new 也可以执行。

##### 6. ES5 和 ES6 子类 this 生成顺序不同

ES5 的继承先生成了子类实例，再调用父类的构造函数修饰子类实例。ES6 的继承先 生成父类实例，再调用子类的构造函数修饰父类实例。这个差别使得 ES6 可以继承内置对象。

##### 7. ES6可以继承静态方法，而构造函数不能

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11253403.html#_labelTop)

### transform、translate、transition 分别是什么属性？CSS 中常用的实现动画方式

三者属性说明
transform 是指变换、变形，是 css3 的一个属性，和 width，height 属性一样；
translate 是 transform 的属性值，是指元素进行 2D(3D)维度上位移或范围变换;
transition 是指过渡效果，往往理解成简单的动画，需要有触发条件。

这里可以补充下 transition 和 animation 的比较，前者一般定义开始结束两个状态，需要有触发条件；而后者引入了关键帧、速度曲线、播放次数等概念，更符合动画的定义，且无需触发条件

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11253403.html#_labelTop)

### 介绍一下rAF(requestAnimationFrame)

   专门用来做动画，不卡顿，用法和setTimeout一样。对 rAF 的阐述 [MDN 资料](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame)

   定时器一直是 js 动画的核心技术，但它们不够精准，因为定时器时间参数是指将执行代码放入 UI 线程队列中等待的时间，如果前面有其他任务队列执行时间过长，则会导致动画延迟，效果不精确等问题。
   所以处理动画循环的关键是知道延迟多长时间合适：时间要足够短，才能让动画看起来比较柔滑平顺，避免多余性能损耗；时间要足够长，才能让浏览器准备好变化渲染。这个时候 rAF 就出现了，采用系统时间间隔(大多浏览器刷新频率是 60Hz，相当于 1000ms/60≈16.6ms)，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制。并且 rAF 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成。

详情：[CSS3动画那么强，requestAnimationFrame还有毛线用？](https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-动画算法/)

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11253403.html#_labelTop)

### javascript 的垃圾回收机制讲一下

定义：指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。

像 C 这样的编程语言，具有低级内存管理原语，如 malloc()和 free()。开发人员使用这些原语显式地对操作系统的内存进行分配和释放。
而 JavaScript 在创建对象(对象、字符串等)时会为它们分配内存，不再使用对时会“自动”释放内存，这个过程称为垃圾收集。

内存生命周期中的每一个阶段:

分配内存 —  内存是由操作系统分配的，它允许您的程序使用它。在低级语言(例如 C 语言)中，这是一个开发人员需要自己处理的显式执行的操作。然而，在高级语言中，系统会自动为你分配内在。
使用内存 — 这是程序实际使用之前分配的内存，在代码中使用分配的变量时，就会发生读和写操作。
释放内存 — 释放所有不再使用的内存,使之成为自由内存,并可以被重利用。与分配内存操作一样,这一操作在低级语言中也是需要显式地执行。

##### 四种常见的内存泄漏：全局变量，未清除的定时器，闭包，以及 dom 的引用

1. 全局变量 不用 var 声明的变量，相当于挂载到 window 对象上。如：b=1; 解决：使用严格模式
2. 被遗忘的定时器和回调函数
3. 闭包
4. 没有清理的 DOM 元素引用

[回到顶部](https://www.cnblogs.com/chenwenhao/p/11253403.html#_labelTop)

### 对前端性能优化有什么了解？一般都通过那几个方面去优化的？

[前端性能优化的七大手段](https://www.cnblogs.com/xiaohuochai/p/9178390.html)

1. 减少请求数量
2. 减小资源大小
3. 优化网络连接
4. 优化资源加载
5. 减少重绘回流
6. 性能更好的API
7. webpack优化

前端安全也经常被问到的，常见的有两种——XSS、CSRF，详见[前端安全](https://www.cnblogs.com/chenwenhao/p/11107175.html)

2.统计字符串出现最多的字母

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
function getMax(str) {
    var hash = {},
        maxstr, max = 1;
    for (var i = 0; i < str.length; i++) {
        if (!hash[str[i]]) {
            hash[str[i]] = 1;
        } else {
            hash[str[i]]++;
        }
        if (hash[str[i]] > max) {
            max = hash[str[i]];
            maxstr = str[i];
        }
    }
    return maxstr;
}

var str = 'abcdeffggghhhhiiiii';
console.log(getMax(str));
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

 

4.去重算法

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
function unique1(arr) {
    var newArr = [];
    for (var i = 0; i < arr.length; i++) {
        if (newArr.indexOf(arr[i]) == -1) {
            newArr.push(arr[i]);
        }
    }
    return newArr;
}

var arr1 = ['b', 'b', 'a', 1, 3, 4, 4];
console.log(unique1(arr1));

function unique2(arr) {
    var hash = {},
        newArr = [];
    for (var i = 0; i < arr.length; i++) {
        if (!hash[arr[i]]) {
            hash[arr[i]] = true;
            newArr.push(arr[i]);
        }
    }
    return newArr;
}

var arr2 = ['b', 'b', 'a', 1, 3, 4, 4];
console.log(unique2(arr2));

function unique3(arr) {
    for (var i = 0; i < arr.length; i++) {
        for (var j = 0; j < arr.length; j++) {
            if (arr[i] === arr[j] && i != j) {
                arr.splice(i, 1);
            }
        }
    }
    return arr;
}

var arr3 = ['b', 'b', 'a', 1, 3, 4, 4];
console.log(unique3(arr3));
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

 

5.二分查找算法（建立在已经排好序的情况下）

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
function binarySearch(arr, data) {
    var end = arr.length - 1,
        start = 0;

    while (start <= end) {
        var middle = Math.floor((start + end) / 2);
        if (arr[middle] > data) {
            end = middle - 1;
        } else if (arr[middle] < data) {
            start = middle + 1;
        } else {
            return middle;
        }
    }
    return -1;

}

var arr = [1, 2, 3, 4, 5, 6];
console.log(binarySearch(arr, 2));
```

**1、写一个js函数，实现对一个数字每3位加一个逗号，如输入100000， 输出100,000（不考虑负数，小数）—百度前端面试题**

![img](https://pic1.zhimg.com/80/v2-5b817921880f456a54a084317ae6c364_720w.jpg)



- **解题思路**

本题是js实现number.toLocaleString()方法，面试题做了简化不考虑负数小数，此题主要是考数据类型及字符串操作，答案不唯一。

按现实思路解题，现实中添加千位分隔符是从后到前，每3位添加逗号，所以这里输入数据转换成字符串后，利用slice方法的输入负数参数从后取的特点，从后取三位数字保存在数组中，并把取剩后的数据递归重复取值，直到数据不足3位，把剩下一起存入数组中。

这时数组中按顺序保存从后到前的分割数据。实例中数组是[‘789’,’456’,’123’]。通过reverse方法倒叙输出，并通过join方法添加逗号。

**2、给定一个字符串，找出其中无重复字符的最长子字符串长度—字节跳动前端面试题**

![img](https://pic4.zhimg.com/80/v2-d8136dca742eb7560c23d1a39e99e86b_720w.jpg)

![img](https://pic1.zhimg.com/80/v2-291f6f8dcd093229bb7d0a9102c826dc_720w.jpg)

- **解题思路**

这题的要点就是无重复字符的理解。首先字符串内字符位置是固定的，我们要采用顺序循环的方式解题，然后就是理解无重复字符的含义，把当前字符串分割，每个小分割内不能出现重复的字符。也就是说分割的字符串是不会互相叠加重复的，每当该段分割的下一个字符与该段分割内字符相同，当即重新开始分割字符。

所以解题时需要一个存储当前分割片段的对象，用来比较下一个字符。并取这个分割片段的长度，与每个分割片段的最大长度比较即可。本题主要考的是题面的理解，以及字符串方法的运用，需要熟练地运用才能快速解题。



**3、实现超出整数存储范围的两个大正整数相加—腾讯前端面试题**

![img](https://pic2.zhimg.com/80/v2-6a8a37d7f089fe690e70177c6acda6f5_720w.jpg)

![img](https://pic1.zhimg.com/80/v2-e9c697d81ad9da8e01b5de0f3dc2f4b0_720w.jpg)

- **解题思路**

首先了解超出存储范围的大数字概念，每种数据类型可存储数据量都是存在范围的

数字类型的范围：

Number.MAX_VALUE = 1.7976931348623157e+308

Number.MIN_VALUE = 5e-324

整数类型的范围：-2-53-253

当超出这个范围，为了避免数据丢失，就要采用其他手段进行运算。在参考答案中，运用数组的方式解决这个问题。首先两个大整数要存储在数组中，要先保证位数对其，我们比较字符串长度把低位数的大整数字符串前面添加相应的0占位， 并逆排序。创建一个新的数组保存运算结果，将两个大整数按从后到前的顺序进行相加减，这里注意进位。把得到的数组反转到正常顺序即可。



**4、任意二维数组的全排列组合—阿里巴巴前端面试题**

![img](https://pic2.zhimg.com/80/v2-b773498514ef9a9cd8ecb195a024c3bd_720w.jpg)

![img](https://pic2.zhimg.com/80/v2-253239f9888feb13a611e6f7f18ddc81_720w.jpg)

- **解题思路**

本题做法不唯一，这里采用了把多项数组逐步两两相乘的方式，第一次先取二维数组前两项组合，把组合的结果在与第三项组合以此类推。这种递归做法简单易懂，把复杂的多项问题简化成两项问题的逐渐递增。



**5、公司最近新研发了一种产品，共生产了n件。有m个客户想购买此产品，已知每个顾客出价。为了确保公平，公司决定要以一个固定的价格出售产品。每一个出价不低于要价的客户将会得到产品（每人只买一个），余下的将会被拒绝购买。请你找出能让公司利润最大化的售价。—京东前端面试题**

![img](https://pic2.zhimg.com/80/v2-e73ad87054ead9b430669cfc42bfb431_720w.jpg)

- **解题思路**

本题是京东的业务演变题，首先要理清思路。本题中，固定出价，以及出价低于产品的顾客会被拒绝购买是解题核心。

条件中已知产品总个数，顾客出价。这里有个小陷阱，会出现N<M供不应求的情况，要特殊考虑。依据题目，我们首先需要对顾客出价排序，这里按升序排列。当供不应求出现时，我们截取出价高的顾客。然后把每个顾客的出价当做最终售价循环，得出最大化利润下的售价。



**6、计算出字符串中出现次数最多的字符是什么，出现了多少次？—华为前端面试题**

![img](https://pic2.zhimg.com/80/v2-188d09407b1c114796c6d94570e5b665_720w.jpg)

![img](https://pic2.zhimg.com/80/v2-eb1d3cf308421e73a31f0a60abdd8dc1_720w.jpg)

- **解题思路**

计算出全部字符出现次数，并留下最大的。首先利用filter（）与indexOf()的方法连用字符串去重，再将得到的作为索引，利用split()分割字符串，得到字符出现次数，比较得出结果。



**7、"123456789876543212345678987654321..."的第n位是什么？—小米面试题**

![img](https://pic1.zhimg.com/80/v2-099e79b07757d9d145ebd0562e896b50_720w.jpg)

- **解题思路**

这道题的答案不唯一，这里可以利用数学中最小循环节的概念解题，找到最小循环节后，利用余数查找第n位数字。



**8、请编写一个 JavaScript 凼数 parseQueryString，它的用途是把 URL 参数解析为一个对象—淘宝面试题**

![img](https://pic3.zhimg.com/80/v2-e169a184ba081af3d44347f5089e00ea_720w.jpg)

- **解题思路**

淘宝这道题是很常用的场景题，这里需要处理好分段次序，首先把？分离，然后按&分割最后按=分割，主要考察字符串的函数运用以及对象的创建。

**9、如果给定的字符串是回文，返回true，反之，返回false。回文：如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是palindrome(回文)。—网易前端面试题**

![img](https://pic3.zhimg.com/80/v2-af83f7dd839aa7bd1182950912376b66_720w.jpg)

- **解题思路**

去掉字符串多余的标点符号和空格，然后把字符串转化成小写来验证此字符串是否为回文。



**10、确保字符串的每个单词首字母都大写，其余部分小写。——搜狐前端面试题**

![img](https://pic2.zhimg.com/80/v2-f721848def1ed04cc4635deec90954e1_720w.jpg)

- **解题思路**

1. 字符串转化成小写；

2. 分割成字符串数组；

3. 新组合字符串元素=首字母转大写+其余小写。

   ```js
   js中的隐式转换
   js中的不同的数据类型之间的比较转换规则如下：
   
   1. 对象和布尔值比较
对象和布尔值进行比较时，对象先转换为字符串，然后再转换为数字，布尔值直接转换为数字
   [] == true;  //false  []转换为字符串'',然后转换为数字0,true转换为数字1，所以为false
   2. 对象和字符串比较
   对象和字符串进行比较时，对象转换为字符串，然后两者进行比较。
   [1,2,3] == '1,2,3' // true  [1,2,3]转化为'1,2,3'，然后和'1,2,3'， so结果为true;
   3. 对象和数字比较
   对象和数字进行比较时，对象先转换为字符串，然后转换为数字，再和数字进行比较。
   [1] == 1;  // true  `对象先转换为字符串再转换为数字，二者再比较 [1] => '1' => 1 所以结果为true
   4. 字符串和数字比较
   字符串和数字进行比较时，字符串转换成数字，二者再比较。
   '1' == 1 // true
   5. 字符串和布尔值比较
   字符串和布尔值进行比较时，二者全部转换成数值再比较。
   '1' == true; // true 
   6. 布尔值和数字比较
   布尔值和数字进行比较时，布尔转换为数字，二者比较。
   true == 1 // true
   许多刚接触js的童鞋看到这么多的转换规则就懵圈了，其实规律很简单，大家可以记下边这个图(是时候展现我高超的绘画技巧了)
   数据转换
   https://upload-images.jianshu.io/upload_images/2791152-ba592aa9b81fe174.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
    ![](./img/==.jpg)

   如图，任意两种类型比较时，如果不是同一个类型比较的话，则按如图方式进行相应类型转换，如对象和布尔比较的话，对象 => 字符串 => 数值 布尔值 => 数值。
   另外，我们来看下一些需要"特别照顾"的。
   
   来看一个有趣的题
   
   [] == false;
   ![] == false;
   这两个的结果都是true,第一个是，对象 => 字符串 => 数值0 false转换为数字0,这个是true应该没问题，
   第二个前边多了个!，则直接转换为布尔值再取反，转换为布尔值时，空字符串(''),NaN,0，null,undefined这几个外返回的都是true, 所以! []这个[] => true 取反为false,所以![] == false为true。
   
   还有一些需要记住的，像：
   undefined == null //true undefined和null 比较返回true，二者和其他值比较返回false
   Number(null) //0
   有写错的地方，欢迎指正，不胜感激！fontSize  -> font-size
   'fontSize'.replace(/([A-Z])/g, function(){return '-' + arguments[1]})
   
   ```
   
   
   
   